<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glmap.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.11.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>glmap.h</h1><div class="fragment"><pre>00001 <font class="comment">/*--License:</font>
00002 <font class="comment">        Kyra Sprite Engine</font>
00003 <font class="comment">        Copyright Lee Thomason (Grinning Lizard Software) 2001-2002</font>
00004 <font class="comment">        www.grinninglizard.com/kyra</font>
00005 <font class="comment">        www.sourceforge.net/projects/kyra</font>
00006 <font class="comment"></font>
00007 <font class="comment">        Kyra is provided under 2 licenses:</font>
00008 <font class="comment"></font>
00009 <font class="comment">        - The GPL, with no additional restrictions.</font>
00010 <font class="comment">        - The LGPL, provided you display the Kyra splash screen, described below.</font>
00011 <font class="comment"></font>
00012 <font class="comment"></font>
00013 <font class="comment">--- GPL License --</font>
00014 <font class="comment">        This program is free software; you can redistribute it and/or</font>
00015 <font class="comment">        modify it under the terms of the GNU General Public License</font>
00016 <font class="comment">        as published by the Free Software Foundation; either version 2</font>
00017 <font class="comment">        of the License, or (at your option) any later version.</font>
00018 <font class="comment"></font>
00019 <font class="comment">        This program is distributed in the hope that it will be useful,</font>
00020 <font class="comment">        but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00021 <font class="comment">        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00022 <font class="comment">        GNU General Public License for more details.</font>
00023 <font class="comment"></font>
00024 <font class="comment">        You should have received a copy of the GNU General Public License</font>
00025 <font class="comment">        along with this program; if not, write to the Free Software</font>
00026 <font class="comment">        Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</font>
00027 <font class="comment"></font>
00028 <font class="comment">        The full text of the license can be found in license.txt</font>
00029 <font class="comment"></font>
00030 <font class="comment"></font>
00031 <font class="comment">--- LGPL License --</font>
00032 <font class="comment">  **Provided you kindly display the Kyra splash screen (details below), </font>
00033 <font class="comment">        you     may use the LGPL license:**</font>
00034 <font class="comment"></font>
00035 <font class="comment">    This library is free software; you can redistribute it and/or</font>
00036 <font class="comment">    modify it under the terms of the GNU Lesser General Public</font>
00037 <font class="comment">    License as published by the Free Software Foundation; either</font>
00038 <font class="comment">    version 2.1 of the License, or (at your option) any later version.</font>
00039 <font class="comment"></font>
00040 <font class="comment">    This library is distributed in the hope that it will be useful,</font>
00041 <font class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00042 <font class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00043 <font class="comment">    Lesser General Public License for more details.</font>
00044 <font class="comment"></font>
00045 <font class="comment">    You should have received a copy of the GNU Lesser General Public</font>
00046 <font class="comment">    License along with this library; if not, write to the Free Software</font>
00047 <font class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</font>
00048 <font class="comment"></font>
00049 <font class="comment">        The full text of the license can be found in lgpl.txt</font>
00050 <font class="comment"></font>
00051 <font class="comment"></font>
00052 <font class="comment">--- Kyra Splash Screen.</font>
00053 <font class="comment"></font>
00054 <font class="comment">        It would be appreciate if you display the Kyra splash screen when using</font>
00055 <font class="comment">        either license, however it is only required for the LGPL. All the</font>
00056 <font class="comment">        resources for the splash are compiled into the library, and it can be</font>
00057 <font class="comment">        accessed through the following API:</font>
00058 <font class="comment"></font>
00059 <font class="comment">                KrEngine::StartSplash</font>
00060 <font class="comment">                KrEngine::UpdateSplash</font>
00061 <font class="comment">                KrEngine::EndSplash</font>
00062 <font class="comment"></font>
00063 <font class="comment">        Full documentation is provided with the KrEngine class. The splash screen</font>
00064 <font class="comment">        should be displayed for 2 seconds.</font>
00065 <font class="comment"></font>
00066 <font class="comment">        Thank you.</font>
00067 <font class="comment">*/</font>
00068 
00069 <font class="preprocessor">#ifndef GLMAP_INCLUDED</font>
00070 <font class="preprocessor"></font><font class="preprocessor">#define GLMAP_INCLUDED</font>
00071 <font class="preprocessor"></font>
00072 <font class="preprocessor">#pragma warning( disable : 4530 )</font>
00073 <font class="preprocessor"></font><font class="preprocessor">#pragma warning( disable : 4786 )</font>
00074 <font class="preprocessor"></font><font class="preprocessor">#include &lt;string&gt;</font>
00075 <font class="preprocessor">#include &lt;ctype.h&gt;</font>
00076 <font class="preprocessor">#include "glutil.h"</font>
00077 <font class="preprocessor">#include "gldebug.h"</font>
00078 <font class="preprocessor">#include "glprime.h"</font>
00079 <font class="preprocessor">#include "gltypes.h"</font>
00080 
00081 <font class="comment">// Standard Hash classes.</font>
00082 <font class="keyword">class </font>GlHash
00083 {
00084   <font class="keyword">public</font>:
00085         U32 HashValue()<font class="keyword"> </font>{ <font class="keywordflow">return</font> val; }
00086   <font class="keyword">protected</font>:
00087         U32 val;        
00088 };
00089 
00090 <font class="keyword">class </font>GlStringHash : <font class="keyword">public</font> GlHash
00091 {
00092   <font class="keyword">public</font>:
00093         GlStringHash( <font class="keyword">const</font> std::string&amp; str )<font class="keyword"></font>
00094 <font class="keyword">        </font>{       
00095                 val = 0;
00096                 <font class="keywordflow">for</font> ( <font class="keywordtype">unsigned</font> i=0; i&lt;str.length() &amp;&amp; i &lt; 32; ++i )
00097                 {
00098                         val &lt;&lt;= 1;
00099                         val |= str[i];
00100                 }
00101         }
00102 };
00103 
00104 template &lt; class T &gt;
00105 <font class="keyword">class </font>GlNumberHash : <font class="keyword">public</font> GlHash
00106 {
00107   <font class="keyword">public</font>:
00108         GlNumberHash( T num )<font class="keyword">   </font>{ val = (T) num; }
00109 };
00110 
00111 
00112 <font class="comment">// A map template class. It associates a KEY with a VALUE.</font>
00113 <font class="comment">// It uses a HASH class to get a hash value from the KEY. 2 Hash classes are</font>
00114 <font class="comment">// provided: GlStringHash and GlNumberHash.</font>
00115 
00116 template &lt; class KEY, class VALUE, class HASH &gt;
00117 <font class="keyword">class </font>GlMap
00118 {
00119   <font class="keyword">public</font>:
00120         GlMap( U32 startSize = 64, U32 grow = 60 );
00121         ~GlMap();
00122 
00123         <font class="comment">// Adds a key value pair. Will fail if the key is not unique.</font>
00124         <font class="keywordtype">bool</font> Add( <font class="keyword">const</font> KEY&amp; key, <font class="keyword">const</font> VALUE&amp; value );
00125         
00126         <font class="comment">// Remove a key value pair. Will fail if the key is not found.</font>
00127         <font class="keywordtype">bool</font> Remove( <font class="keyword">const</font> KEY&amp; key );
00128         
00129         <font class="comment">// Returns true if the key is found, and writes the result to value.</font>
00130         <font class="comment">// Value will not be set if the key is not found.</font>
00131         <font class="keywordtype">bool</font> Find( <font class="keyword">const</font> KEY&amp; key, VALUE* value );
00132 
00133         <font class="comment">// PRIVATE! But silly template friends too hard.</font>
00134         <font class="keyword">enum</font> {
00135                 EXPAND = 4
00136         };
00137 
00138         <font class="keyword">struct </font>Item
00139         {
00140                 KEY             key;
00141                 VALUE   value;
00142                 Item*   next;
00143         };
00144 
00145         <font class="comment">// Grow the hash table. Dicey work, and slow.</font>
00146         <font class="keywordtype">void</font> Grow( <font class="keywordtype">unsigned</font> newsize );
00147 
00148         U32 numBuckets;
00149         Item** buckets;
00150         U32 grow;
00151         U32 numItems;
00152 };
00153 
00154 
00155 
00156 
00157 template &lt; class KEY, class VALUE, class HASH &gt;
00158 <font class="keyword">inline</font> GlMap&lt; KEY, VALUE, HASH&gt;::GlMap( U32 startSize, U32 _grow )<font class="keyword"></font>
00159 <font class="keyword"></font>{
00160         numBuckets = GlPrime( startSize, 1 );
00161         buckets = <font class="keyword">new</font> Item*[ numBuckets ];
00162         memset( buckets, 0, <font class="keyword">sizeof</font>( Item* ) * numBuckets );
00163         grow = _grow;
00164         numItems = 0;
00165 
00166 <font class="preprocessor">        #ifdef DEBUG</font>
00167 <font class="preprocessor"></font>                <font class="comment">//GLOUTPUT( "Created Map: %d buckets\n", numBuckets );</font>
00168 <font class="preprocessor">        #endif</font>
00169 <font class="preprocessor"></font>};
00170 
00171 
00172 template &lt; class KEY, class VALUE, class HASH &gt;
00173 <font class="keyword">inline</font> GlMap&lt; KEY, VALUE, HASH&gt;::~GlMap()<font class="keyword"></font>
00174 <font class="keyword"></font>{
00175         <font class="keywordflow">for</font>( U32 i=0; i&lt;numBuckets; ++i )
00176         {       
00177                 <font class="keywordflow">while</font> ( buckets[i] )
00178                 {
00179                         Item* next = buckets[i]-&gt;next;
00180                         <font class="keyword">delete</font> buckets[i];
00181                         buckets[i] = next;
00182                 }
00183         }
00184                 
00185         <font class="comment">// Everything is in the new list, create new buckets and put it back in.</font>
00186         <font class="keyword">delete</font> [] buckets;
00187 };
00188 
00189 
00190 template &lt; class KEY, class VALUE, class HASH &gt;
00191 <font class="keyword">inline</font> <font class="keywordtype">void</font> GlMap&lt; KEY, VALUE, HASH&gt;::Grow( <font class="keywordtype">unsigned</font> newsize )<font class="keyword"></font>
00192 <font class="keyword"></font>{
00193 <font class="preprocessor">        #ifdef DEBUG</font>
00194 <font class="preprocessor"></font>        <font class="keywordtype">int</font> itemcount = 0;
00195 <font class="preprocessor">        #endif</font>
00196 <font class="preprocessor"></font>
00197         <font class="comment">// Yep. Unlink everything, put in a linked list, and re-insert.</font>
00198         Item *root = 0;
00199         <font class="keywordflow">for</font>( U32 i=0; i&lt;numBuckets; ++i )
00200         {       
00201                 <font class="keywordflow">while</font> ( buckets[i] )
00202                 {
00203                         Item* next = buckets[i]-&gt;next;
00204 
00205                         buckets[i]-&gt;next = root;
00206                         root = buckets[i];
00207 
00208                         buckets[i] = next;
00209 
00210 <font class="preprocessor">                        #ifdef DEBUG</font>
00211 <font class="preprocessor"></font>                        ++itemcount;
00212 <font class="preprocessor">                        #endif</font>
00213 <font class="preprocessor"></font>                }
00214         }
00215 <font class="preprocessor">        #ifdef DEBUG</font>
00216 <font class="preprocessor"></font>        <font class="keywordtype">int</font> comparecount = 0;
00217         <font class="keywordflow">for</font>( Item* it = root; it; it = it-&gt;next )
00218                 ++comparecount;
00219         GLASSERT( comparecount == itemcount );
00220 <font class="preprocessor">        #endif</font>
00221 <font class="preprocessor"></font>                
00222         <font class="comment">// Everything is in the new list, create new buckets and put it back in.</font>
00223         <font class="keyword">delete</font> [] buckets;
00224         buckets = 0;
00225 
00226 <font class="preprocessor">        #ifdef DEBUG</font>
00227 <font class="preprocessor"></font>                <font class="comment">//GLOUTPUT( "Rebuilding map (from %d)...", numBuckets );</font>
00228 <font class="preprocessor">        #endif</font>
00229 <font class="preprocessor"></font>
00230         numBuckets = GlPrime( newsize, 1 );
00231 <font class="preprocessor">        #ifdef DEBUG</font>
00232 <font class="preprocessor"></font>                <font class="comment">//GLOUTPUT( "%d buckets\n", numBuckets );</font>
00233 <font class="preprocessor">        #endif</font>
00234 <font class="preprocessor"></font>
00235         buckets = <font class="keyword">new</font> Item*[ numBuckets ];
00236         memset( buckets, 0, <font class="keyword">sizeof</font>( Item* ) * numBuckets );
00237 
00238         <font class="keywordflow">while</font> ( root )
00239         {
00240                 Item* next = root-&gt;next;
00241 
00242                 HASH hash( root-&gt;key );
00243                 U32 which = hash.HashValue() % numBuckets;
00244 
00245                 root-&gt;next = buckets[ which ];
00246                 buckets[ which ] = root;
00247 
00248                 root = next;
00249         }
00250 }
00251 
00252 
00253 template &lt; class KEY, class VALUE, class HASH &gt;
00254 <font class="keyword">inline</font> <font class="keywordtype">bool</font> GlMap&lt; KEY, VALUE, HASH&gt;::Add( <font class="keyword">const</font> KEY&amp; key, <font class="keyword">const</font> VALUE&amp; value )<font class="keyword"></font>
00255 <font class="keyword"></font>{
00256         VALUE dummy;
00257         <font class="keywordflow">if</font> ( Find( key, &amp;dummy ) ) 
00258                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
00259 
00260         <font class="comment">// Do we need to get bigger?</font>
00261         <font class="keywordflow">if</font> ( ( ( numItems + 1 ) * 100 / numBuckets ) &gt; grow )
00262         {
00263                 Grow( GlMax( numItems * EXPAND, numBuckets * EXPAND ) );
00264         }
00265 
00266         <font class="comment">// Add the key in, if it is unique.</font>
00267         HASH hash( key );
00268         U32 which = hash.HashValue() % numBuckets;
00269 
00270         Item* item      = <font class="keyword">new</font> Item;
00271         item-&gt;key       = key;
00272         item-&gt;value = value;
00273         item-&gt;next      = buckets[ which ];
00274 
00275         buckets[ which ] = item;
00276         ++numItems;
00277         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00278 }
00279 
00280 
00281 template &lt; class KEY, class VALUE, class HASH &gt;
00282 <font class="keyword">inline</font> <font class="keywordtype">bool</font> GlMap&lt; KEY, VALUE, HASH&gt;::Find( <font class="keyword">const</font> KEY&amp; key, VALUE* value )<font class="keyword"></font>
00283 <font class="keyword"></font>{
00284         HASH hash( key );
00285         U32 which = hash.HashValue() % numBuckets;
00286 
00287         Item* item = buckets[which];
00288         
00289         <font class="keywordflow">while</font>( item )
00290         {
00291                 <font class="keywordflow">if</font> ( item-&gt;key == key )
00292                 {
00293                         *value = item-&gt;value;
00294                         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00295                 }
00296                 item = item-&gt;next;
00297         }
00298         <font class="keywordflow">return</font> <font class="keyword">false</font>;   
00299 }
00300 
00301 
00302 template &lt; class KEY, class VALUE, class HASH &gt;
00303 <font class="keyword">inline</font> <font class="keywordtype">bool</font> GlMap&lt; KEY, VALUE, HASH&gt;::Remove( <font class="keyword">const</font> KEY&amp; key )<font class="keyword"></font>
00304 <font class="keyword"></font>{
00305         HASH hash( key );
00306         U32 which = hash.HashValue() % numBuckets;
00307 
00308         Item* item = buckets[which];
00309         Item* prev = 0;
00310         
00311         <font class="keywordflow">while</font>( item )
00312         {
00313                 <font class="keywordflow">if</font> ( item-&gt;key == key )
00314                 {
00315                         <font class="keywordflow">if</font> ( prev )
00316                                 prev-&gt;next = item-&gt;next;
00317                         <font class="keywordflow">else</font>
00318                                 buckets[ which ] = item-&gt;next;
00319 
00320                         <font class="keyword">delete</font> item;
00321                         --numItems;
00322                         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00323                 }
00324                 prev = item;
00325                 item = item-&gt;next;
00326         }
00327         <font class="keywordflow">return</font> <font class="keyword">false</font>;   
00328 }
00329 
00330 
00331 template &lt; class KEY, class VALUE, class HASH &gt;
00332 <font class="keyword">class </font>GlMapIterator
00333 {
00334   <font class="keyword">public</font>:
00335         GlMapIterator( GlMap&lt; KEY, VALUE, HASH &gt;&amp; _map )<font class="keyword">        </font>{ map = &amp;_map; bucket=0; item=0; }
00336 
00337         <font class="keywordtype">void</font> Begin()<font class="keyword">            </font>{ bucket=0; item=map-&gt;buckets[0]; FindValid(); }
00338         <font class="keywordtype">void</font> Next()<font class="keyword">                     </font>{ item=item-&gt;next; FindValid(); }
00339         <font class="keywordtype">bool</font> Done()<font class="keyword">                     </font>{ <font class="keywordflow">return</font> ( bucket &lt; 0 ); }
00340 
00341         <font class="keywordtype">void</font> Current( KEY* key, VALUE* value )<font class="keyword"></font>
00342 <font class="keyword">        </font>{
00343                 <font class="keywordflow">if</font> ( item )
00344                 {
00345                         *key = item-&gt;key;
00346                         *value = item-&gt;value;
00347                 }
00348         }
00349 
00350   <font class="keyword">private</font>:
00351         GlMap&lt; KEY, VALUE, HASH &gt;* map;
00352         <font class="keywordtype">int</font> bucket;
00353         <font class="keyword">typename</font> GlMap&lt; KEY, VALUE, HASH &gt;::Item* item;
00354 
00355         <font class="keywordtype">void</font> FindValid()<font class="keyword"></font>
00356 <font class="keyword">        </font>{
00357                 <font class="keywordflow">if</font> (    bucket &lt; 0                              <font class="comment">// we are done</font>
00358                          || ( item &amp;&amp; bucket &gt;=0 ))     <font class="comment">// we have a current value</font>
00359                 {
00360                         <font class="keywordflow">return</font>;
00361                 }
00362                 GLASSERT( item == 0 );                  <font class="comment">// else we should have current value</font>
00363                 <font class="keywordflow">for</font> ( ++bucket; bucket &lt; map-&gt;numBuckets; ++bucket )
00364                 {
00365                         <font class="keywordflow">if</font> ( map-&gt;buckets[bucket] )
00366                         {
00367                                 item = map-&gt;buckets[ bucket ];
00368                                 <font class="keywordflow">return</font>;
00369                         }
00370                 }
00371                 bucket = -1;
00372                 item = 0;
00373         }
00374 };
00375 
00376 
00377 <font class="preprocessor">#endif</font>
00378 <font class="preprocessor"></font>
</pre></div><hr><address><small>Generated on Fri Feb 7 20:44:20 2003 for Kyra by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.11.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
