/////////////////////////////////////////////////////////////////////////////
// Name:        MainFrame.cpp
// Purpose:     
// Author:      
// Modified by: 
// Created:     01/08/06 14:25:46
// RCS-ID:      
// Copyright:   
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 01/08/06 14:25:46

#if defined(__GNUG__) && !defined(__APPLE__)
#pragma implementation "MainFrame.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
#include "wx/ifm/dragndrop.h"
#include "wx/sysopt.h"
#include "../gameEngine/GameControl.h"
#include "../gameEditor/MainPanel.h"
#include "../gameEditor/UndoControl.h"
#include "../gameEditor/ActorProperty.h"
#include "../gameEditor/LoadSaveGame.h"
#include "PanelProperty.h"
#include "Behavior/wxJigsawEditor/wxJigsawEditorMainFrame.h"
#include "Behavior/wxJigsawEditor/wxJigsawEditorDocument.h"
#include "PanelActors.h"
#include "PanelScript.h"
#include "GameGraph.h"

//#include "wx/stc/stc.h"  // styled text control

/*
#include "Edit/defsext.h"     // Additional definitions
#include "Edit/edit.h"        // Edit module
#include "Edit/prefs.h"       // Prefs
*/


#include "wx/config.h"










#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include "wxgameeditor.h"
#include "DlgSaveLayout.h"

////@begin XPM images
////@end XPM images


bool EngineTick();



#define MENU_PANEL_BASE_ID 12345
#define MENU_PANEL_LAYOUT_ID (MENU_PANEL_BASE_ID + 100)






/*!
 * wxMainFrame type definition
 */

IMPLEMENT_CLASS( wxMainFrame, wxFrame )

/*!
 * wxMainFrame event table definition
 */

BEGIN_EVENT_TABLE( wxMainFrame, wxFrame )

////@begin wxMainFrame event table entries
    EVT_CLOSE( wxMainFrame::OnCloseWindow )
    EVT_ERASE_BACKGROUND( wxMainFrame::OnEraseBackground )

	EVT_MENU( XRCID("ID_MENU_NEW"), wxMainFrame::OnMenuNewClick )

	EVT_MENU( XRCID("ID_MENU_OPEN"), wxMainFrame::OnMenuOpenClick )

    EVT_MENU( XRCID("ID_MENU_EXIT"), wxMainFrame::OnMenuExitClick )

    EVT_MENU( XRCID("ID_MENU_TITLE_BAR"), wxMainFrame::OnMenuTitleBarClick )

    EVT_MENU( XRCID("ID_MENU_LAYOUT_RESET"), wxMainFrame::OnMenuLayoutResetClick )

    EVT_MENU( XRCID("ID_GAME_MODE"), wxMainFrame::OnGameModeClick )

	EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, wxMainFrame::OnMRUFile)

////@end wxMainFrame event table entries

	EVT_ACTIVATE(wxMainFrame::OnActivate)
	EVT_MOVE(wxMainFrame::OnMove)
	EVT_SIZE(wxMainFrame::OnSize)
	EVT_ICONIZE(wxMainFrame::OnIconize) 
	EVT_MAXIMIZE(wxMainFrame::OnMaximize) 

	EVT_MENU_OPEN(wxMainFrame::OnMenuOpen)	
	EVT_MENU_RANGE(MENU_PANEL_BASE_ID, MENU_PANEL_BASE_ID + 32, wxMainFrame::OnMenuPanel)
	EVT_MENU_RANGE(MENU_PANEL_LAYOUT_ID, MENU_PANEL_LAYOUT_ID + 99, wxMainFrame::OnMenuLoadLayout)

	EVT_MENU( XRCID("ID_MENU_LAYOUT_SAVE"), wxMainFrame::OnMenuLayoutSaveClick )
    EVT_MENU( XRCID("ID_MENU_LAYOUT_SAVE_AS"), wxMainFrame::OnMenuLayoutSaveAsClick )
    EVT_MENU( XRCID("ID_MENU_LAYOUT_DELETE"), wxMainFrame::OnMenuLayoutDeleteClick )
    EVT_MENU( XRCID("ID_MENU_LAYOUT_RESTORE"), wxMainFrame::OnMenuLayoutRestoreClick )


	EVT_DROP_FILES(wxMainFrame::OnDropFiles)
	EVT_LAYOUT_STATE(wxID_ANY, wxMainFrame::OnLayoutState)


END_EVENT_TABLE()

/*!
 * wxMainFrame constructors
 */

wxMainFrame *wxMainFrame::mainFrame = NULL;

wxMainFrame::wxMainFrame( )
{
	mainFrame = this;
	m_ifm = NULL;
	sdlPanel = NULL;
	panelProperty = NULL;
	pBehavior = NULL;
	bMaximized = false;
}

wxMainFrame::wxMainFrame( wxString _applicationDir, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
	mainFrame = this;
	statusBar = NULL;
	m_ifm = NULL;
	sdlPanel = NULL;
	panelProperty = NULL;
	pBehavior = NULL;
	bMaximized = false;
	applicationDir = _applicationDir;

    Create( NULL, id, caption, pos, size, style );
}

wxMainFrame::~wxMainFrame( )
{
	panelProperty = NULL;
	pBehavior = NULL;
	mainFrame = NULL;
	m_root_panel = NULL;
}

/*!
 * wxMainFrame creator
 */

bool wxMainFrame::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
	//Allow 24bits icons
	/*if(wxTheApp->GetComCtl32Version() >= 600 && ::wxDisplayDepth() >= 24)
	{
		wxSystemOptions::SetOption(wxT("msw.remap"), 2);
	}
	else*/
	{
		//Disable system theme remap (without this, icons don't look good)
		wxSystemOptions::SetOption(wxT("msw.remap"), 0);
	}

////@begin wxMainFrame member initialisation
////@end wxMainFrame member initialisation

////@begin wxMainFrame creation
    SetParent(parent);
    CreateControls();
    Centre();
////@end wxMainFrame creation

	//Create status bar
	statusBar = NULL; //Need any status bar? statusBar = new wxGedStatusBar(this, wxID_ANY, wxST_SIZEGRIP);	
	SetStatusBar(statusBar);

	int widths[] = { -1 };

	if(GetStatusBar()) 
	{
		GetStatusBar()->SetFieldsCount(WXSIZEOF(widths), widths);
		GetStatusBar()->SetStatusText(wxT("Ready"), 0);
	}
	

	//Setup tool bar color
	if(GetToolBar()) GetToolBar()->SetBackgroundColour(wxBackground_Pen);
	

    Setup_wxIFM();

	DragAcceptFiles(true);
      
    return true;
}


void wxMainFrame::Setup_wxIFM()
{
    // panel as the only child
    m_root_panel = new wxPanel(this);

    // connect erase background for the root panel to get flicker free drawing back
    m_root_panel->Connect(wxEVT_ERASE_BACKGROUND, wxEraseEventHandler(wxMainFrame::OnEraseBackground));
		
    // create the interface management object
    m_ifm = new wxInterfaceManager(m_root_panel);

    m_ifm->Initialize(true/*, IFM_NO_RESIZE_UPDATE*/);
    //m_ifm->SetInterfaceRect(wxRect(50,50,800,800));

	wxIFMDefaultDockingPlugin::setUseTargetButtons(false);
	


	// demonstrate using the configuration api to change the font for captions and tabs
    // Note that wxSYS_DEFAULT_GUI_FONT is the default setting, so this won't actually
    // change the appearance of the demo, its only for demonstrating the api
	// Set the colors before create the panels to avoid system colors in close buttons

    wxIFMCaptionConfig &caption_config = wxIFMDefaultPanelPlugin::GetCaptionConfig();

    caption_config.set_font(wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT));
	caption_config.set_font_colour(colorCaptionText);

	

	


	

    wxIFMTabConfig &tab_config = wxIFMDefaultPanelPlugin::GetTabConfig();
    tab_config.set_font(wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT));
	tab_config.set_rounding_factor(-1);
	tab_config.set_top(true);



    // specify the status bar pane to use for displaying messages
    if(GetStatusBar()) m_ifm->SetStatusMessagePane(GetStatusBar(), 0);


	// First we need to create the add child data object
    // We are using the default interface, so we use its child data object
    wxIFMDefaultChildData data;

    
	// add some windows in a format most common to programming IDE's

	panelProperty = new PanelProperty(m_root_panel); 
	//pBehavior = new Behavior(m_root_panel);

	///////////////////////////////////////
	//Behavior
	wxDocManager *m_DocManager = new wxDocManager;
	wxDocTemplate * docTemplate = new wxDocTemplate(m_DocManager, _("Jigsaw Scene"),
		wxT("*.jigscene;*.xml"), wxEmptyString, wxT("jigscene"), 
		wxT("wxJigsawEditorDoc"), wxT("wxJigsawEditorView"),
		CLASSINFO(wxJigsawEditorDocument), CLASSINFO(wxJigsawEditorView));
	wxUnusedVar(docTemplate);
	m_DocManager->SetMaxDocsOpen(1);
	pBehavior = new wxJigsawEditorMainFrame( m_DocManager, (wxFrame*)m_root_panel, wxJigsawEditorMainFrame::ID_WXJIGSAWEDITORMAINFRAME, SYMBOL_WXJIGSAWEDITORMAINFRAME_TITLE, SYMBOL_WXJIGSAWEDITORMAINFRAME_POSITION, SYMBOL_WXJIGSAWEDITORMAINFRAME_SIZE, wxTAB_TRAVERSAL | wxNO_BORDER | wxFRAME_TOOL_WINDOW);
	pBehavior->SetExtraStyle(0);		
	m_DocManager->CreateDocument(wxEmptyString, wxDOC_NEW );		
	///////////////////////////////////////

	panelActors = new PanelActors(m_root_panel);
	panelScript = new PanelScript(m_root_panel);

	//Increase CURRENT_LAYOUT_VERSION when add a new panel

    data.m_name = wxT("Actors");
    data.m_type = IFM_CHILD_GENERIC;
	data.m_desiredSize.Set(200, GetSize().GetHeight() - panelProperty->GetMaxHeight() - 64	);
    data.m_minSize.Set(120, 100);
	data.m_maxSize.Set(350, IFM_NO_MAXIMUM);
    data.m_orientation = IFM_ORIENTATION_RIGHT; // bottom of the frame
	data.m_tabify = false; // make this child a tab of the previously added child
	data.m_hideable = true;
	data.bCanDrag = true;
    data.m_child = panelActors;  
	AppendPanelToMenu(data.m_child, data.m_name);
	//data.m_newRow = true;
    m_ifm->AddChild(&data);
    



	data.m_name = wxT("Properties");
    data.m_minSize.Set(160, 100);
	data.m_orientation = IFM_ORIENTATION_RIGHT; // left of the frame
    data.m_tabify = false; // not a tab this time
	data.m_hideable = true; // this window can be closed
	data.m_newRow = false;
	data.bCanDrag = true;

	
	data.m_child = panelProperty;
	data.m_desiredSize.Set(200, panelProperty->GetMaxHeight());
	data.m_maxSize.Set(350, IFM_NO_MAXIMUM ); //Don't works if set max value
	AppendPanelToMenu(data.m_child, data.m_name);
	m_ifm->AddChild(&data);

	wxIFMTab *propertiesTab = wxIFMTab::lastCreatedTab;



   
    


	
	
	data.m_name = wxT("Stage");
    data.m_type = IFM_CHILD_GENERIC;
    data.m_minSize.Set(100, 100);
	data.m_maxSize = IFM_NO_MAXIMUM_SIZE;
	data.m_desiredSize.Set(350, 350);
    data.m_orientation = IFM_ORIENTATION_BOTTOM; // bottom of the frame
	data.m_tabify = false; // make this child a tab of the previously added child
    data.m_hideable = false; // prevent this window from being closed by the user
	data.m_newRow = false;
	data.bCanDrag = false;
	data.m_child = sdlPanel = new SDLPanel(m_root_panel);
	m_ifm->AddChild(&data);	
	wxIFMTab *stageTab = wxIFMTab::lastCreatedTab;

	 



    data.m_name = wxT("Behavior");
    data.m_minSize.Set(120, 100);
	data.m_maxSize = IFM_NO_MAXIMUM_SIZE;
	data.m_orientation = IFM_ORIENTATION_BOTTOM; 
    data.m_tabify = true; // make this a tab
	data.m_hideable = true;
	data.m_newRow = false;
	data.bCanDrag = true;
	
	data.m_child = pBehavior;
	data.m_desiredSize.Set(600, 150);
	AppendPanelToMenu(data.m_child, data.m_name);

    m_ifm->AddChild(&data);



	data.m_name = wxT("Script");
    data.m_type = IFM_CHILD_GENERIC;
    data.m_desiredSize.Set(600, 150);
    data.m_minSize.Set(150, 70);
	data.m_maxSize = IFM_NO_MAXIMUM_SIZE;
    data.m_orientation = IFM_ORIENTATION_BOTTOM; // bottom of the frame
    data.m_hideable = true;
	data.m_tabify = true; 
	data.m_newRow = false;
	data.bCanDrag = true;

	data.m_child = panelScript;
	data.m_child->SetSizeHints(0,0);
	AppendPanelToMenu(data.m_child, data.m_name);
	m_ifm->AddChild(&data);



	data.m_name = wxT("Schematic");
    data.m_type = IFM_CHILD_GENERIC;
    data.m_desiredSize.Set(350, 350);
    data.m_minSize.Set(150, 70);
	data.m_maxSize = IFM_NO_MAXIMUM_SIZE;
    data.m_orientation = IFM_ORIENTATION_BOTTOM; // bottom of the frame
    data.m_hideable = true;
	data.m_tabify = true; 
	data.m_newRow = false;
	data.bCanDrag = true;
	data.m_child = new GameGraph(m_root_panel);
	data.m_child->SetSizeHints(0,0);
	AppendPanelToMenu(data.m_child, data.m_name);
	m_ifm->AddChild(&data);


	//Select Stage
	wxIFMSelectTabEvent event1(stageTab->m_tab->m_parent, stageTab, false);
	m_ifm->GetActiveIP()->ProcessPluginEvent(event1);

	//Select Properties
	wxIFMSelectTabEvent event2(propertiesTab->m_tab->m_parent, propertiesTab, false);
	m_ifm->GetActiveIP()->ProcessPluginEvent(event2);


    // we are done creating children, now lets make a textbox for the content window
	/*wxTextCtrl *content = new wxTextCtrl(m_root_panel, wxID_ANY, wxT("This is the content window"),
        wxPoint(), wxSize(), wxTE_MULTILINE | wxTE_WORDWRAP);
    m_ifm->SetContentWindow( content );*/ 

    

    

	//Layout
	//This version will works only with one layout
	//and the Reset Layout option
	//To works with multiple layouts, put this menu definition in the xrc file:
	/*<object class="wxMenu" name="ID_MENU_LAYOUTS">
        <label>Layouts</label>
        <object class="wxMenuItem" name="ID_MENU_LAYOUT_SAVE">
            <label>Save</label>
        </object>
        <object class="wxMenuItem" name="ID_MENU_LAYOUT_SAVE_AS">
            <label>Save As...</label>
        </object>
        <object class="wxMenuItem" name="ID_MENU_LAYOUT_DELETE">
            <label>Delete ...</label>
        </object>
        <object class="wxMenuItem" name="ID_MENU_LAYOUT_RESTORE">
            <label>Restore</label>
        </object>
        <object class="separator">
        </object>
    </object>*/

	layoutControl = new wxIFMLayoutControl();
	layoutControl->Init(applicationDir + wxT("layout.dat"));
	

	wxStringList layoutList(layoutControl->GetLayoutList());

	for(int i = 0; i < layoutList.size(); i++)
	{
		AppendLayoutToMenu(layoutList[i]);
	}

	SetupMRU();

	m_ifm->UpdateConfiguration();

	//Set focus to stage, if active
	if(sdlPanel && sdlPanel->IsShown()) 
	{
		sdlPanel->SetFocus();
	}

	//Limit min frame size
	SetSizeHints(750, 550);	
}



/*!
 * Control creation for wxMainFrame
 */

void wxMainFrame::CreateControls()
{    
////@begin wxMainFrame content construction
    // Generated by DialogBlocks, 02/07/06 18:11:49 (unregistered)

    wxXmlResource::Get()->LoadFrame(this, GetParent(), wxT("ID_FRAME"));
////@end wxMainFrame content construction

    // Create custom windows not generated automatically here.

////@begin wxMainFrame content initialisation

////@end wxMainFrame content initialisation
}

/*!
 * Should we show tooltips?
 */

bool wxMainFrame::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap wxMainFrame::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin wxMainFrame bitmap retrieval
    wxUnusedVar(name);
    if (name == wxT("open_b.gif"))
    {
        wxBitmap bitmap(_T("open_b.gif"), wxBITMAP_TYPE_GIF);
        return bitmap;
    }
    else if (name == wxT("save_b.gif"))
    {
        wxBitmap bitmap(_T("save_b.gif"), wxBITMAP_TYPE_GIF);
        return bitmap;
    }
    else if (name == wxT("play_b.gif"))
    {
        wxBitmap bitmap(_T("play_b.gif"), wxBITMAP_TYPE_GIF);
        return bitmap;
    }
    return wxNullBitmap;
////@end wxMainFrame bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon wxMainFrame::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin wxMainFrame icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end wxMainFrame icon retrieval
}
/*!
 * wxEVT_ERASE_BACKGROUND event handler for ID_FRAME
 */

void wxMainFrame::OnEraseBackground( wxEraseEvent& event )
{

}


/*!
 * wxEVT_CLOSE_WINDOW event handler for ID_FRAME
 */

void wxMainFrame::OnCloseWindow( wxCloseEvent& event )
{
	//Can exit?
	if(event.CanVeto())
	{		
		if(GameControl::Get()->getGameMode())
		{
			event.Veto();
			MainPanel::Get()->OnKeyUp(SDLK_ESCAPE);
			return;
		}
		else if(GameControl::Get()->Modified())
		{
			int answer = wxMessageBox(wxT("This will discard the current game.\nProceed anyway?"), wxT("Confirm"), wxYES_NO | wxCENTRE);
			
			if(answer != wxYES)
			{
				event.Veto();
				return;
			}			
		}
	}


	//Save current layout
	if(layoutControl)
	{
		layoutControl->SaveCurrent();
		layoutControl->Save();
		delete layoutControl;
		layoutControl = NULL;
	}

	if(m_ifm)
	{
		// shut down the interface management object
		m_ifm->Shutdown();
		
		// it is now safe to delete it
		delete m_ifm;
		m_ifm = NULL;
	}

	if(statusBar)
	{
 		delete statusBar;
		statusBar = NULL;
	}

	//delete sdlPanel;

    event.Skip();
}

void wxMainFrame::SetupSDLPanelGameModePosition()
{
	if(SDLPanel::Get())
	{
		HidePanels();

		wxRect sdlRect = SDLPanel::Get()->GetRect();
		if(GetRootPanel())
		{			
			GetRootPanel()->Move(-sdlRect.x, -sdlRect.y);

			//Solve the repaint problem when stage is smaller than game resolution
			GetRootPanel()->SetClientSize(GameControl::Get()->Width() + sdlRect.x, GameControl::Get()->Height() + sdlRect.y);
			SDLPanel::Get()->SetSize(GameControl::Get()->Width(), GameControl::Get()->Height());
		}
		
		//Need to refresh DirectX window
		SDLPanel::Get()->Show(false);
		SDLPanel::Get()->Show(true);
		
		SDLPanel::Get()->SetFocus();
	}
}

void wxMainFrame::OnActivate(wxActivateEvent& event)
{
    /*if(m_ifm && event.GetActive()) 
	{
		m_ifm->Update(IFM_DEFAULT_RECT, true);
	}*/

	/*if(event.GetActive()) 
	{
		wxShowEvent event(GetId(), true);
		event.SetEventObject(this);
		
		GetEventHandler()->ProcessEvent(event);
	}*/

	

	if(GameControl::Get() && GameControl::Get()->getGameMode())
	{
		if(GameControl::Get()->getFullScreen())
		{
		}
		else
		{
			if(event.GetActive())
			{
				SetupSDLPanelGameModePosition();
				GameControl::Get()->SuspendGame(false);
			}
			else if(GameControl::Get()->getSuspendGameIfLostFocus())
			{
				GameControl::Get()->SuspendGame(true);
			}
		}
	}
}

bool wxMainFrame::Show(bool show)
{
	if(!show) wxWindowBase::Show(true); //Without this, can fail in the Show function
	return wxFrame::Show(show);
}

void wxMainFrame::OnMenuOpen(wxMenuEvent &event) 
{
    wxMenu *menuTitleBar = NULL, *menuLayout = NULL;
	if(!GetMenuBar()) return;

	GetMenuBar()->FindItem(XRCID("ID_MENU_TITLE_BAR"), &menuTitleBar);
	GetMenuBar()->FindItem(XRCID("ID_MENU_LAYOUT_DELETE"), &menuLayout);

	if(menuTitleBar == event.GetMenu())
	{
		wxwxMenuItemListNode *node;

		//Update panel itens
		node = menuTitleBar->GetMenuItems().GetFirst(); 

        while (node) 
        { 
                wxMenuItem *mi = node->GetData(); 
				wxWindow *panel = m_panels[mi->GetId()];				

				if(panel && mi->IsCheckable())
				{
					mi->Check(m_ifm->IsChildVisible(panel));
				}
				else if(mi->GetId() == XRCID("ID_MENU_TITLE_BAR"))
				{
					mi->Check(GetWindowStyle() & (wxCAPTION | wxSYSTEM_MENU | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX));
				}
                
                node = node->GetNext(); 
        } 
				

		//Update Delete
		if(menuLayout)
		{
			node = menuLayout->GetMenuItems().GetFirst(); 
			
			while (node) 
			{ 
                wxMenuItem *mi = node->GetData(); 
				if(mi->GetId() == XRCID("ID_MENU_LAYOUT_DELETE"))
				{
					//Set state
					mi->Enable(layoutControl->size() > 1);
					break;
				}
                
                node = node->GetNext(); 
			}
		}

		
	}
	else
	{
		event.Skip();
	}
	
}

void wxMainFrame::OnMenuPanel(wxCommandEvent &event)
{
    // hide or show the appropriate window

    m_ifm->ShowChild(m_panels[event.GetId()], event.IsChecked(), true);
}

void wxMainFrame::HidePanels()
{
	for( wxWindowMap::iterator i = m_panels.begin(), end = m_panels.end(); i != end; ++i )
    {
        m_ifm->ShowChild(i->second, false);
    }

	m_ifm->UpdateConfiguration();
}

void wxMainFrame::OnMenuLoadLayout(wxCommandEvent &event)
{
	layoutControl->LoadLayout(m_layouts[event.GetId()]);
}

void wxMainFrame::AppendPanelToMenu(wxWindow *window, wxString &name)
{
	if(GetMenuBar())
	{
		//Append menu
		wxMenu *menu = NULL;
		wxMenuItem *menuItem = GetMenuBar()->FindItem(XRCID("ID_MENU_TITLE_BAR"), &menu);
		
		if(menuItem && menu)
		{
			int id = MENU_PANEL_BASE_ID + m_panels.size();
			
			menu->AppendCheckItem(id, name);
			m_panels[id] = window;
		}
	}
}

void wxMainFrame::AppendLayoutToMenu(wxString name)
{
	if(GetMenuBar())
	{
		//Append menu
		wxMenu *menu = NULL;
		wxMenuItem *menuItem = GetMenuBar()->FindItem(XRCID("ID_MENU_LAYOUT_DELETE"), &menu);
		
		if(menuItem && menu)
		{
			static int id = MENU_PANEL_LAYOUT_ID;// + layoutControl->size();
			
			menu->Append(id, name);
			m_layouts[id] = name;
			id++;
		}
	}
}

void wxMainFrame::RemoveLayoutFromMenu(wxString name)
{
	if(GetMenuBar())
	{
		//Append menu
		wxMenu *menu = NULL;
		GetMenuBar()->FindItem(XRCID("ID_MENU_LAYOUT_DELETE"), &menu);
		
		if(menu)
		{
			int id = menu->FindItem(name);
			if(id != wxNOT_FOUND)
			{
				menu->Remove(id);
				m_layouts.erase(id);
			}		
		}
	}
}

void wxMainFrame::AddLayout(wxString name)
{
	AppendLayoutToMenu(name);
	layoutControl->AddLayout(name);
}

void wxMainFrame::RemoveLayout(wxString name)
{	
	if(layoutControl->RemoveLayout(name))
	{
		RemoveLayoutFromMenu(name);
	}
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENU_TITLE_BAR
 */

void wxMainFrame::OnMenuTitleBarClick( wxCommandEvent& event )
{
	long style = GetWindowStyle();

	if(event.IsChecked())
	{		
		style |= wxCAPTION | wxSYSTEM_MENU | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX;
		SetWindowStyle(style);


		//Without this, need go to other window and select this again to show the title bar
		Show(false);
		Show(true);

	}
	else
	{			
		Maximize(true);

		style &= ~(wxCAPTION | wxSYSTEM_MENU | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX);
		SetWindowStyle(style);		
	}
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENUITEM
 */

void wxMainFrame::OnMenuExitClick( wxCommandEvent& event )
{
	Close();	
}

void wxMainFrame::OnMenuNewClick( wxCommandEvent& event )
{
	bool bNewOk = false;

	if (GameControl::Get()->Modified())
	{
		int answer = wxMessageBox(wxT("This will discard the current game.\nProceed anyway?"), wxT("Confirm"), wxYES_NO | wxCENTRE);

		if(answer == wxYES)
		{			
			bNewOk = true;
		}
	}
	else
	{
		bNewOk = true;
	}
	
	if(bNewOk)
	{
		GameControl::Get()->NewGame();
		UndoControl::Get()->Clear();
		
		/*Close actor dialog*/
		ActorProperty::Destroy();
	}	
}

void wxMainFrame::SetupMRU()
{
	wxMenu *menu = NULL;
	wxMenuItem *menuItem = GetMenuBar()->FindItem(XRCID("ID_MENU_EXIT"), &menu);

	if(menuItem && menu)
	{		
		wxConfig config("GameEditor");
		mru.UseMenu(menu);
		mru.Load(config);		
	}

}


void wxMainFrame::OnMRUFile(wxCommandEvent& event)
{
    wxString file(mru.GetHistoryFile(event.GetId() - wxID_FILE1));
    if (!file.empty())
	{
		LoadSaveGame::Load(file.mbc_str(), true);
	}
}

void wxMainFrame::OnMenuOpenClick( wxCommandEvent& event )
{
	wxFileDialog* OpenDialog = new wxFileDialog(
		this, _("Load Game"), wxEmptyString, wxEmptyString, 
		_("Ged files (*.ged)|*.ged"), wxFD_OPEN, wxDefaultPosition);

	if (OpenDialog->ShowModal() == wxID_OK)
	{
		if(LoadSaveGame::Load(OpenDialog->GetPath().mbc_str(), true))
		{			
			wxConfig config("GameEditor");
			mru.AddFileToHistory(OpenDialog->GetPath());
			mru.Save(config);
		}
		else
		{
			//mru.Remove(file);
					

			wxMessageBox(wxT("Can't load this project"), wxT("Error"), wxOK | wxCENTRE);
			GameControl::Get()->NewGame();
			UndoControl::Get()->Clear();
		}

		
		//SetTitle(wxString("Edit - ") << OpenDialog->GetFilename()); // Set the Title to reflect the file open
	}
}


void wxMainFrame::OnMenuLayoutSaveAsClick( wxCommandEvent& event )
{
	DlgSaveLayout dialog(true);
	dialog.ShowModal();
}


void wxMainFrame::OnMenuLayoutRestoreClick( wxCommandEvent& event )
{
	layoutControl->LoadCurrent();	 
}




void wxMainFrame::OnMenuLayoutSaveClick( wxCommandEvent& event )
{
	layoutControl->SaveCurrent();
}



void wxMainFrame::OnMenuLayoutDeleteClick( wxCommandEvent& event )
{
	DlgSaveLayout dialog(false);
	dialog.ShowModal(); 
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_MENU_LAYOUT_RESET
 */

void wxMainFrame::OnMenuLayoutResetClick( wxCommandEvent& event )
{
	int answer = wxMessageBox(wxT("Do you want load the original layout configuration?"), wxT("Confirm"), wxYES_NO | wxCENTRE);

	if(answer == wxYES)
	{
		layoutControl->LoadDefault();
		panelProperty->ResetState();
		//pBehavior->ResetState();
	}
}

void wxMainFrame::OnMove(wxMoveEvent & event)
{
	//Need to refresh DirectX window
	if(sdlPanel && sdlPanel->IsShown()) 
	{
		sdlPanel->Show(false);
		sdlPanel->Show(true);

		if(GameControl::Get() && GameControl::Get()->getGameMode() && !GameControl::Get()->getFullScreen())
		{
			sdlPanel->SetFocus();
		}
	}

	
	if(!IsMaximized())
	{
		wxRect m_NonMaximizedRect(wxIFMLayoutControl::getNonMaximizedFrameRect());
		m_NonMaximizedRect.SetPosition(GetRect().GetPosition());
		wxIFMLayoutControl::setNonMaximizedFrameRect(m_NonMaximizedRect);
	}

	event.Skip();
}

void wxMainFrame::OnSize(wxSizeEvent & event)
{
	//Need to refresh DirectX window
	/*if(sdlPanel && sdlPanel->IsShown()) 
	{
		//sdlPanel->Show(false);
		//sdlPanel->Show(true);

		//if(m_ifm) m_ifm->UpdateConfiguration();

		EngineTick();
	}*/

	bool bMax = IsMaximized();

	if(!bMaximized && !bMax)
	{
		wxIFMLayoutControl::setNonMaximizedFrameRect(GetRect());
	}

	if(bMaximized && !bMax)
	{
		//Window restored
		mainFrame->SetSize(wxIFMLayoutControl::getNonMaximizedFrameRect());
	}

	bMaximized = bMax;

	event.Skip();
}

void wxMainFrame::OnIconize(wxIconizeEvent & event)
{
	event.Skip();
}

void wxMainFrame::OnMaximize(wxMaximizeEvent & event)
{
	bMaximized = true;
	event.Skip();
}

void wxMainFrame::OnDropFiles(wxDropFilesEvent & event)
{
	if(event.GetNumberOfFiles() > 0 && event.GetFiles())
	{
		//File dropped, send a SDL event
		static char fileName[256];
		SDL_Event sdlEvent;
		
		memset(&sdlEvent, 0, sizeof(SDL_Event));
		memcpy(fileName, event.GetFiles()[0].GetData(), event.GetFiles()[0].Length());
		
		sdlEvent.type = SDL_DROPFILES;
		sdlEvent.user.data1 = fileName;
		SDL_PushEvent(&sdlEvent);
	}
}



/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_GAME_MODE
 */

void wxMainFrame::OnGameModeClick( wxCommandEvent& event )
{
	if(!GameControl::Get()->getGameMode())
	{
		MainPanel::Get()->OnButton(NULL, BT_GAME_MODE);
		while(EngineTick() && GameControl::Get()->getGameMode());
	}
}


void wxMainFrame::OnLayoutState(wxLayoutStateEvent& event)
{
	if(panelProperty && pBehavior)
	{
		switch(event.GetType())
		{
		case LAYOUT_STATE_SAVE:
			panelProperty->SaveState(*event.GetOutputStream());
			//pBehavior->SaveState(*event.GetOutputStream());
			break;
			
		case LAYOUT_STATE_LOAD:
			panelProperty->LoadState(*event.GetInputStream());
			//pBehavior->LoadState(*event.GetInputStream());
			break;
		}
	}
}
